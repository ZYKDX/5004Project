壹 尺寸
	version 1: 21*21
	version 2: 25*25 。。。
	使用version2
	
	数据： int[][] DATA = new int[25][25];
	    	左上角：DATA[0][0]   右下角：DATA[24][24]
	Image:  25*25 grid layout
		不可使用JButton，使用。。。

	00  01  02  ... 024
	10  11  12  ... 124
	...
	240 241 242 ... 2424

	根据编码规则填充DATA数组，再根据DATA数组填充颜色

	setActionCommand： 0 white 1 black
	getActionCommand： 0 setBackground WHITE 1 setBackGround BLACK

贰 定位图案：
    1. position detection pattern
        标记二维码的矩形大小
    	固定大小 回字，包含一条白边。左上，右上，左下三个位置
    2. timing patterns
        同样是为了定位
    	两条，连接三个position detection pattern
    	黑白相间,位置是固定的
    3. alignment patterns
        辅助定位
    	比较小的回字
    	version 2只需要一个，位置也是固定的

叁 功能性数据
    1.format information
        存放格式化数据
    2.version information (version 2不需要)
肆 数据码和纠错码
    编码步骤：先对源数据进行编码，然后根据编码结果得到纠错码，最后在结尾加上用于补齐的字节
    1. data code
        对原始数据进行编码：给定一个字符串，将其变成一个二进制数
	有多种编码模式，我们使用字节编码 Byte Mode 模式指示符：0100 (可以同时容纳大小写)
	纠错级别：L，查表得知2-L可以容纳的字符数是32
               字符计数指示符：二进制数，表示源字符串的字符个数, 位于模式指示符之后
	    长度是固定的，在Version 2 + Byte Mode下，长度是8
 	    假设源字符串的长度是 5  "Hello" 则字符计数指示符是  00000101 （左侧用0补齐8位）
	这样得到的是  0010 00000101
	
	然后对 源字符串 进行编码(ISO8859-1，再变成8 bit binary)
	H - 01001000   e - 01100101   l - 01101100  o - 01101111
	
	得到的是 0010 00000101 01001000 01100101 01101100 01101100 01101111
	分别是： byte mode indicator, String length indicator, H, e, l, l, o
	

	然后补齐
	现有的version和纠错级别下，一共需要多少位： 2L - 34 bit * 8 -> 272 required bits
	目前得到的一共52位，需要补齐到272位
	1.末尾最多补4个0 （如果少的位数>=4，先补4个0在右边， 如果少的位数小于4，补0即可）
		得到 0010 00000101 01001000 01100101 01101100 01101100 01101111 0000
	2. 如果此时不是8的倍数，则在右边再补0直到8的倍数（这里不需要补）
	3. 如果此时还是不够长度，则在后面一直加以下的序列，直到补齐
              11101100 00010001
	结果： 	0010 00000101 01001000 01100101 01101100 01101100 01101111 0000 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 

    2. Error Correction Coding
        对于2L，每个block的Error Correction codeword长度为10， 1个group，1个block，其中包括所有的34个 data codewords
	总结： 1个group，其中有1个block，包含所有34个data codewords， 以及10个EC codewords
	
	使用的Error Correction方法是Reed-Solomon Error correction
	1.之前得到的结果是
	00100000 01010100 10000110 01010110 11000110 11000110 11110000 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 （写成8位的形式）
        十进制： 32 84 134 86 198 198 240 236 17 236 17 236 17 236 17 236 17 236 17 236 17 236 17 236 17 236 17 236 17 236 17 236 17 236 (34 in total)
	所以message多项式为：
		32x^33 + 84x^32 + 134x^31 + ... + 17x + 236
	generator多项式为：（对于10个EC codewords，因此该多项式是固定的）
		X^10 + a^251X^9 + a^67X^8 + a^46X^7 + a^61X^6 + a^118X^5 + a^70X^4 + a^64X^3 + a^94X^2 + a^32X + a^45
	然后用generator多项式除message多项式（重复34次,得到一个含有10项的多项式，其中的10个系数就是最终的EC codewords）

		1. 对两个多项式进行预处理
		    先对message多项式的每一项乘以 X^10 （10是EC长度）
		    得到 32x^43 + 84x^42 + 134x^41 + ... + 17x^11 + 236X^10
		    generator多项式的次数应该对齐，因此乘以 X^33得到
		    X^43 + a^251X^42 + a^67X^41 + a^46X^40 + a^61X^39 + a^118X^38 + a^70X^37 + a^64X^36 + a^94X^35 + a^32X^34 + a^45X^33
		2. 
